namespace Olympus.Generators;

[Generator]
public sealed class RoutesGenerator : IIncrementalGenerator {

	private class RouteNode(string name) {

		public string Name { get; } = name;

		public Dictionary<string, RouteNode> Children { get; } = [];

		public List<RouteEntry> Routes { get; } = [];

	}

	private readonly record struct RouteEntry(string Name, string Value, string ModuleName, string FullKey);

	private static bool TryGenerateSource(ResourceCollection resourceCollection, in List<Diagnostic> diagnostics, [NotNullWhen(true)] out string? sourceCode, CancellationToken cancellationToken) {

		var resourceInformation = resourceCollection.BaseInformation;

		if (!resourceInformation.ResourceFile.TryGetResourceDataAndValues(diagnostics, out var values, cancellationToken)) {

			sourceCode = string.Empty;

			return false;

		}

		if (values.Count == 0) {

			sourceCode = string.Empty;

			diagnostics.Add(Diagnostic.Create(BuildHelper.EmptyResourceFile, Location.Create(resourceInformation.ResourceFile.Path, default, default)));

			return false;

		}

		var rootNode = BuildRoutesTree(values, resourceInformation.ResourceFile, diagnostics);

		if (diagnostics.Any(diag => diag.Severity == DiagnosticSeverity.Error)) {

			sourceCode = string.Empty;

			return false;

		}

		var rootNamespace = resourceInformation.ResourceSettings.Namespace;
		var className = resourceInformation.ClassName;
		var members = GenerateNodeMembers(rootNode, "    ");

		var builder = new StringBuilder(4096);

		builder.AppendLine($$"""
			// <auto-generated/>

			#nullable enable

			namespace {{rootNamespace}};

			/// <summary>Routes class for '{{resourceInformation.ResourceFile.Path}}'.</summary>
			public static class {{className}} {

			{{members}}

			}

			""");

		sourceCode = builder.ToString().TrimLines();

		return true;

	}

	private static RouteNode BuildRoutesTree(Dictionary<string, XElement> values, AdditionalText file, List<Diagnostic> diagnostics) {

		var root = new RouteNode("Root");

		foreach (var pair in values) {

			var key = pair.Key;
			var value = pair.Value.Value.Trim();
			var parts = key.Split('.');
			var dataElement = pair.Value.Parent;

			if (parts.Length < 2) {

				diagnostics.Add(Diagnostic.Create(BuildHelper.InvalidRouteKey, BuildHelper.GetXElementLocation(file, dataElement!, key), key));

				continue;

			}

			var moduleName = BuildHelper.GetIdentifierFromResourceName(parts[0]);
			var segments = parts.Skip(1).ToArray();
			var currentNode = root;

			foreach (var segment in segments.Take(segments.Length - 1)) {

				var safeName = BuildHelper.GetIdentifierFromResourceName(segment);

				if (!currentNode.Children.TryGetValue(safeName, out var child)) {

					child = new RouteNode(safeName);

					currentNode.Children[safeName] = child;

				}

				currentNode = child;

			}

			var propertyName = BuildHelper.GetIdentifierFromResourceName(segments.Last());

			currentNode.Routes.Add(new RouteEntry(propertyName, value, moduleName, key));

		}

		return root;

	}

	private static string GenerateNodeMembers(RouteNode node, string indent) {

		var builder = new StringBuilder(4096);

		foreach (var route in node.Routes) {

			var docComment = BuildHelper.GetTrimmedDocComment(route.Value);

			builder.AppendLine($"{indent}/// <summary>Route: {docComment}</summary>");
			builder.AppendLine($"{indent}public const string {route.Name} = @\"{route.Value}\";");
			builder.AppendLine();

		}

		foreach (var child in node.Children.Values) {

			builder.AppendLine($"{indent}/// <summary>Routes for {child.Name}.</summary>");
			builder.AppendLine($"{indent}public static class {child.Name} {{");
			builder.AppendLine();

			var childMembers = GenerateNodeMembers(child, indent + "    ");

			builder.AppendLine(childMembers);
			builder.AppendLine();

			builder.AppendLine($"{indent}}}");
			builder.AppendLine();

		}

		if (indent.Length == 4) {

			builder.AppendLine($"{indent}/// <summary>Gets all routes defined in this class.</summary>");
			builder.AppendLine($"{indent}public static global::System.Collections.Generic.IEnumerable<global::Olympus.Core.Routing.RouteInfo> GetRoutesInfo() {{");
			builder.AppendLine();

			TraverseAndYield(node, builder, indent + "    ");
			builder.AppendLine();

			builder.AppendLine($"{indent}}}");
			builder.AppendLine();

		}

		return builder.ToString().TrimEnd();

	}

	private static void TraverseAndYield(RouteNode node, StringBuilder builder, string indent) {

		foreach (var route in node.Routes) {

			var section = node.Name == "Root" ? "Root" : node.Name;

			builder.AppendLine($"{indent}yield return new global::Olympus.Core.Routing.RouteInfo {{ Name = \"{route.FullKey}\", Value = @\"{route.Value}\", Module = \"{route.ModuleName}\", Section = \"{section}\" }};");

		}

		foreach (var child in node.Children.Values) {

			TraverseAndYield(child, builder, indent);

		}

	}

	private static ResourceInformation[] CreateResourceInformation(AnalyzerConfigOptionsProvider optionsProvider, AdditionalText resourceFile, CompilationInformation compilationInfo) {

		var globalOptions = optionsProvider.GlobalOptions;
		var resourceOptions = optionsProvider.GetOptions(resourceFile);

		if (!(resourceOptions.GetValue("build_metadata.EmbeddedResource.ResourceType") == "Routes")) return [];

		var rootNamespace = globalOptions.GetValue("build_property.RootNamespace") ?? compilationInfo.AssemblyName;
		var customNamespace = resourceOptions.GetValue("build_metadata.EmbeddedResource.Namespace");
		var isPublic = resourceOptions.GetBoolValue("build_metadata.EmbeddedResource.IsPublic") ?? true;
		var className = resourceOptions.GetValue("build_metadata.EmbeddedResource.ClassName");
		var resourceFileName = Path.GetFileNameWithoutExtension(resourceFile.Path);
		var resourceAccessName = className is null || string.IsNullOrEmpty(className) ? string.Join(".", rootNamespace, resourceFileName) : className;

		BuildHelper.SplitName(resourceAccessName, out var resourceNamespace, out var resourceClassName);

		try {

			CultureInfo.GetCultureInfo(resourceClassName);

			return [];

		} catch (CultureNotFoundException) { }

		return [
			new ResourceInformation() {
				CompilationInformation = compilationInfo,
				ResourceFile = resourceFile,
				ResourceSettings = new ResourceSettings {
					IsPublic = isPublic,
					RootNamespace = rootNamespace,
					Namespace = !string.IsNullOrEmpty(customNamespace) ? customNamespace : resourceNamespace,
					ClassName = !string.IsNullOrEmpty(className) ? className : resourceClassName,
					DefaultLang = null,
					EmitFormatMethods = false,
				},
				ResourceFileName = resourceFileName,
				ResourceName = string.Join(".", rootNamespace, resourceFileName),
				Namespace = resourceNamespace,
				ClassName = resourceClassName,
			},
		];

	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		var resources = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith("Routes.resx", StringComparison.OrdinalIgnoreCase));
		var compilation = context.CompilationProvider.Select(static (compilation, _) => new CompilationInformation { AssemblyName = compilation.AssemblyName });
		var resourcesToGenerate = resources.Combine(context.AnalyzerConfigOptionsProvider.Combine(compilation)).SelectMany(static (values, _) => { (var resourceFile, (var optionsProvider, var compilationInfo)) = values; return CreateResourceInformation(optionsProvider, resourceFile, compilationInfo); });

		context.RegisterSourceOutput(

			resourcesToGenerate,

			static (context, resourceInformation) => {

				try {

					List<Diagnostic> diagnostics = [];

					var collection = new ResourceCollection {
						BaseInformation = resourceInformation,
						OtherLanguages = ImmutableDictionary<CultureInfo, AdditionalText>.Empty,
						FileHintName = $"{resourceInformation.ResourceFileName}.Designer.g.cs"
					};

					if (TryGenerateSource(collection, diagnostics, out var sourceText, context.CancellationToken)) {

						context.AddSource(
							$"{resourceInformation.ResourceFileName}.Designer.g.cs",
							SourceText.From(sourceText, Encoding.UTF8, SourceHashAlgorithm.Sha256)
						);

					}

					foreach (var diagnostic in diagnostics) {

						context.ReportDiagnostic(diagnostic);

					}

				} catch (OperationCanceledException) {

					throw;

				} catch (Exception exception) {

					var errorText = $"#error RoutesGenerator failed: {exception.ToString().Replace("\n", " ")}";
					context.AddSource($"Error_{resourceInformation.ResourceFileName}.g.cs", SourceText.From(errorText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

			}

		);

	}

}
