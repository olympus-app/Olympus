namespace Olympus.Generators;

[Generator]
public sealed class DatabaseGenerator : IIncrementalGenerator {

	private const string IModelInterface = "Microsoft.EntityFrameworkCore.Metadata.IModel";

	private static bool TryGenerateSource(Compilation compilation, AnalyzerConfigOptions globalOptions, [NotNullWhen(true)] out string? sourceCode) {

		sourceCode = string.Empty;

		if (!globalOptions.TryGetString("SolutionName", out var solutionName)) return false;

		if (!globalOptions.TryGetHostInfo(out var builderType, out var hostPrefix) || hostPrefix != "Api") return false;

		var registrations = GetRegistrationsCode(compilation, solutionName);
		var rootNamespace = compilation.AssemblyName ?? $"{solutionName}.{hostPrefix}.Host";

		var builder = new StringBuilder(2048);

		builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable

            using Microsoft.Extensions.DependencyInjection;

            namespace {{rootNamespace}};

            /// <summary>Provides an extension method for registering EF Core database optimized model.</summary>
            public static class DatabaseRegistrator {

                /// <summary>Registers discovered EF Core database optimized model.</summary>
                public static void AddDatabaseModel(this {{builderType}} builder) {

            {{registrations}}

                }

            }

            """);

		sourceCode = builder.ToString().TrimLines();

		return true;

	}

	private static string GetRegistrationsCode(Compilation compilation, string solutionName) {

		var iModelSymbol = compilation.GetTypeByMetadataName(IModelInterface);

		if (iModelSymbol is null) return "        // Microsoft.EntityFrameworkCore.Metadata.IModel not found.";

		var builder = new StringBuilder();
		var hasModels = false;

		foreach (var assembly in compilation.GetSolutionAssemblies(solutionName)) {

			foreach (var type in assembly.GetAllTypes()) {

				if (type.IsConcreteClass() && type.Implements(iModelSymbol) && HasStaticInstanceProperty(type, iModelSymbol)) {

					var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

					builder.AppendLine($"        // Registered optimized model: {type.Name}");
					builder.AppendLine($"        builder.Services.AddSingleton<global::Microsoft.EntityFrameworkCore.Metadata.IModel>(static _ => {typeName}.Instance!);");

					hasModels = true;

				}

			}

		}

		if (!hasModels) builder.AppendLine("        // No optimized models found. EF Core will use JIT compilation.");

		return builder.ToString().TrimEnd();

	}

	private static bool HasStaticInstanceProperty(INamedTypeSymbol type, INamedTypeSymbol returnType) {

		return type.GetMembers("Instance").OfType<IPropertySymbol>().Any(p => p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && (SymbolEqualityComparer.Default.Equals(p.Type, returnType) || p.Type.Implements(returnType)));

	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		var compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

		context.RegisterSourceOutput(compilationAndOptions, static (context, source) => {

			(var compilation, var optionsProvider) = source;
			var globalOptions = optionsProvider.GlobalOptions;

			try {

				if (TryGenerateSource(compilation, globalOptions, out var sourceText)) {

					context.AddSource("DatabaseRegistrator.g.cs", SourceText.From(sourceText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

			} catch (OperationCanceledException) {

				throw;

			} catch (Exception exception) {

				var errorText = $"#error DatabaseGenerator failed: {exception.ToString().Replace("\n", " ")}";

				context.AddSource("Error_DatabaseGenerator.g.cs", SourceText.From(errorText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

			}

		});

	}

}
