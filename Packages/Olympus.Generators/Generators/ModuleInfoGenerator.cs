namespace Olympus.Generators;

[Generator]
public sealed class ModuleInfoGenerator : IIncrementalGenerator {

	private const string KeyCodeName = "CodeName";
	private const string KeyDisplayName = "DisplayName";
	private const string KeyBaseRoute = "BaseRoute";
	private const string KeyApiVersions = "ApiVersions";

	private static bool TryGenerateModuleClass(ResourceInformation info, List<Diagnostic> diagnostics, [NotNullWhen(true)] out string? sourceCode) {

		if (!info.ResourceFile.TryGetResourceDataAndValues(diagnostics, out var values, default)) {

			sourceCode = string.Empty;

			return false;

		}

		var rootNamespace = info.Namespace;
		var moduleName = info.ClassName.Replace("Module", "").Replace("Info", "");
		var className = $"{moduleName}Module";
		var resourceName = $"{rootNamespace}.{info.ResourceFileName}";
		var codeName = values.TryGetValue(KeyCodeName, out var cn) ? cn.Value.Trim() : moduleName;
		var displayNameDoc = values.TryGetValue(KeyDisplayName, out var dn) ? dn.Value.Trim() : moduleName;
		var baseRoute = values.TryGetValue(KeyBaseRoute, out var br) ? br.Value.Trim() : $"/{moduleName.ToLowerInvariant()}";
		var apiVersionsStr = values.TryGetValue(KeyApiVersions, out var av) ? av.Value.Trim() : "1";
		var apiVersions = apiVersionsStr.Split([';', ','], StringSplitOptions.RemoveEmptyEntries).Select(static v => v.Trim()).Where(static v => int.TryParse(v, out _)).ToList();
		var apiArray = apiVersions.Count > 0 ? string.Join(", ", apiVersions) : "1";
		var cultureCode = BuildHelper.GetCultureCode(null);
		var singletonCode = BuildHelper.GetSingletonCode(className);
		var resourceManagerCode = BuildHelper.GetResourceManagerCode(resourceName, className, true);
		var getStringCode = BuildHelper.GetGetStringCode(true);

		var builder = new StringBuilder(4096);

		builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable

            namespace {{rootNamespace}};

            /// <summary>Module class for {{moduleName}} module.</summary>
            public sealed partial class {{className}} {

            {{singletonCode}}

            {{cultureCode}}

            {{resourceManagerCode}}

            {{getStringCode}}

                /// <summary>Module's assembly.</summary>
                public static global::System.Reflection.Assembly Assembly => typeof({{className}}).Assembly;

                /// <summary>Module's code name.</summary>
                public const string {{KeyCodeName}} = "{{codeName}}";

                /// <summary>Module's localized display name.</summary>
                public string {{KeyDisplayName}} => GetString("{{KeyDisplayName}}");

                /// <summary>Module's base route.</summary>
                public const string {{KeyBaseRoute}} = "{{baseRoute}}";

                /// <summary>Module's supported API versions.</summary>
                public static int[] {{KeyApiVersions}} => [{{apiArray}}];

                /// <summary>Module's routes.</summary>
                public static global::System.Collections.Generic.List<global::Olympus.Core.Routing.RouteInfo> Routes => [.. {{moduleName}}Routes.GetRoutesInfo()];

                /// <summary>Module's permissions.</summary>
                public static global::System.Collections.Generic.List<global::Olympus.Core.Identity.PermissionInfo> Permissions => [.. {{moduleName}}Permissions.Values.GetPermissionsInfo()];

            }

            """);

		sourceCode = builder.ToString().TrimLines();

		return true;

	}

	private static bool TryGenerateModuleInfoClass(ResourceInformation info, [NotNullWhen(true)] out string? sourceCode) {

		var moduleName = info.ClassName.Replace("ModuleInfo", "");
		var moduleClass = $"{moduleName}Module";
		var className = $"{moduleName}ModuleInfo";

		var builder = new StringBuilder(1024);

		builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable

            namespace {{info.Namespace}};

            /// <summary>Module info class for {{moduleName}} module.</summary>
            public sealed partial class {{className}} : global::Olympus.Core.Modules.AppModuleInfo {

                /// <inheritdoc />
                public override global::System.Reflection.Assembly Assembly => {{moduleClass}}.Assembly;

                /// <inheritdoc />
                public override string CodeName => {{moduleClass}}.CodeName;

                /// <inheritdoc />
                public override string DisplayName => {{moduleClass}}.Values.DisplayName;

                /// <inheritdoc />
                public override string BaseRoute => {{moduleClass}}.BaseRoute;

                /// <inheritdoc />
                public override int[] ApiVersions => {{moduleClass}}.ApiVersions;

                /// <inheritdoc />
                public override global::System.Collections.Generic.List<global::Olympus.Core.Routing.RouteInfo> Routes => {{moduleClass}}.Routes;

                /// <inheritdoc />
                public override global::System.Collections.Generic.List<global::Olympus.Core.Identity.PermissionInfo> Permissions => {{moduleClass}}.Permissions;

            }

            """);

		sourceCode = builder.ToString().TrimLines();

		return true;

	}

	private static ResourceInformation CreateResourceInformation(AnalyzerConfigOptionsProvider optionsProvider, AdditionalText resourceFile, CompilationInformation compilationInfo, string moduleName) {

		var rootNamespace = optionsProvider.GlobalOptions.GetValue("build_property.RootNamespace") ?? compilationInfo.AssemblyName;
		var resourceOptions = optionsProvider.GetOptions(resourceFile);
		var customNamespace = resourceOptions.GetValue("build_metadata.EmbeddedResource.Namespace");
		var finalNamespace = !string.IsNullOrEmpty(customNamespace) ? customNamespace : rootNamespace;
		var resourceFileName = Path.GetFileNameWithoutExtension(resourceFile.Path);

		return new ResourceInformation {
			CompilationInformation = compilationInfo,
			ResourceFile = resourceFile,
			ResourceFileName = resourceFileName,
			ResourceName = string.Join(".", rootNamespace, resourceFileName),
			Namespace = finalNamespace,
			ClassName = moduleName,
			ResourceSettings = new ResourceSettings {
				IsPublic = true,
				RootNamespace = rootNamespace,
				Namespace = finalNamespace,
				ClassName = moduleName,
				DefaultLang = null,
				EmitFormatMethods = false,
			}
		};

	}

	private static bool IsModuleArchendLayer(AnalyzerConfigOptions globalOptions) {

		globalOptions.TryGetValue("build_property.IsModulePackage", out var isModule);
		globalOptions.TryGetValue("build_property.IsArchendLayer", out var isArchend);

		return string.Equals(isModule, "true", StringComparison.OrdinalIgnoreCase) && string.Equals(isArchend, "true", StringComparison.OrdinalIgnoreCase);

	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		var resources = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith("ModuleInfo.resx", StringComparison.OrdinalIgnoreCase));
		var compilation = context.CompilationProvider.Select(static (compilation, _) => new CompilationInformation { AssemblyName = compilation.AssemblyName });
		var provider = resources.Combine(context.AnalyzerConfigOptionsProvider.Combine(compilation));

		context.RegisterSourceOutput(provider, static (context, source) => {

			(var resourceFile, (var optionsProvider, var compilationInfo)) = source;
			var globalOptions = optionsProvider.GlobalOptions;

			if (!IsModuleArchendLayer(globalOptions)) return;

			try {

				List<Diagnostic> diagnostics = [];

				var resourceName = Path.GetFileNameWithoutExtension(resourceFile.Path);
				var modulePrefix = resourceName.Replace("Module", "").Replace("Info", "");

				var resourceInfo = CreateResourceInformation(optionsProvider, resourceFile, compilationInfo, modulePrefix);

				if (TryGenerateModuleClass(resourceInfo, diagnostics, out var staticSource)) {

					context.AddSource($"{modulePrefix}Module.g.cs", SourceText.From(staticSource, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

				if (TryGenerateModuleInfoClass(resourceInfo, out var instanceSource)) {

					context.AddSource($"{modulePrefix}ModuleInfo.g.cs", SourceText.From(instanceSource, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

				foreach (var diagnostic in diagnostics) {

					context.ReportDiagnostic(diagnostic);

				}

			} catch (OperationCanceledException) {

				throw;

			} catch (Exception exception) {

				var errorText = $"#error ModuleInfoGenerator failed: {exception.ToString().Replace("\n", " ")}";
				context.AddSource($"Error_{Path.GetFileName(resourceFile.Path)}.g.cs", SourceText.From(errorText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

			}

		});

	}

}
