namespace Olympus.Generators;

[Generator]
public sealed class ModuleOptionsGenerator : IIncrementalGenerator {

	private static bool TryGenerateOptionsClass(ResourceInformation info, List<Diagnostic> diagnostics, [NotNullWhen(true)] out string? sourceCode) {

		if (!ReadResxValues(info.ResourceFile, diagnostics, out _)) {

			sourceCode = string.Empty;

			return false;

		}

		var moduleName = info.ClassName.Replace("Module", "").Replace("Info", "");
		var optionsClass = $"{moduleName}Options";
		var staticClass = $"{moduleName}Module";

		var builder = new StringBuilder(2048);

		builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable

            namespace {{info.Namespace}};

            /// <summary>Module options class for {{moduleName}} module.</summary>
            public sealed partial class {{optionsClass}} : global::Olympus.Core.Modules.AppModuleOptions {

                /// <inheritdoc />
                public override string CodeName => {{staticClass}}.CodeName;

                /// <inheritdoc />
                public override string DisplayName => {{staticClass}}.Values.DisplayName;

                /// <inheritdoc />
                public override string BaseRoute => {{staticClass}}.BaseRoute;

                /// <inheritdoc />
                public override void Configure(global::Microsoft.Extensions.Configuration.IConfiguration configuration) {

                    var handled = false;

                    OnConfigure(configuration, ref handled);

                    if (!handled) {

                        var section = $"Modules:{CodeName}";

                        configuration.GetSection(section).Bind(this);

                    }

                }

                /// <summary>Hook to customize configuration logic. Set <paramref name="handled"/> to true to bypass the default binding logic.</summary>
                partial void OnConfigure(global::Microsoft.Extensions.Configuration.IConfiguration configuration, ref bool handled);

            }

            """);

		sourceCode = builder.ToString();

		return true;

	}

	private static bool ReadResxValues(AdditionalText file, List<Diagnostic> diagnostics, out Dictionary<string, string> values) {

		values = [];

		if (!file.TryGetResourceDataAndValues(diagnostics, out var rawValues, default)) return false;

		foreach (var pair in rawValues) {

			var value = pair.Value.Value.Trim();

			if (!string.IsNullOrEmpty(value)) values[pair.Key] = value;

		}

		return true;

	}

	private static ResourceInformation CreateResourceInformation(AnalyzerConfigOptionsProvider optionsProvider, AdditionalText resourceFile, CompilationInformation compilationInfo, string moduleName) {

		var rootNamespace = optionsProvider.GlobalOptions.GetValue("build_property.RootNamespace") ?? compilationInfo.AssemblyName;
		var resourceOptions = optionsProvider.GetOptions(resourceFile);
		var customNamespace = resourceOptions.GetValue("build_metadata.EmbeddedResource.Namespace");
		var finalNamespace = !string.IsNullOrEmpty(customNamespace) ? customNamespace : rootNamespace;
		var resourceFileName = Path.GetFileNameWithoutExtension(resourceFile.Path);

		return new ResourceInformation {
			CompilationInformation = compilationInfo,
			ResourceFile = resourceFile,
			ResourceFileName = resourceFileName,
			ResourceName = string.Join(".", rootNamespace, resourceFileName),
			Namespace = finalNamespace,
			ClassName = moduleName,
			ResourceSettings = new ResourceSettings {
				IsPublic = true,
				RootNamespace = rootNamespace,
				Namespace = finalNamespace,
				ClassName = moduleName,
				DefaultLang = null,
				EmitFormatMethods = false
			}
		};

	}

	private static bool IsModuleArchendLayer(AnalyzerConfigOptions globalOptions) {

		globalOptions.TryGetValue("build_property.IsModulePackage", out var isModule);
		globalOptions.TryGetValue("build_property.IsArchendLayer", out var isArchend);

		return string.Equals(isModule, "true", StringComparison.OrdinalIgnoreCase) && string.Equals(isArchend, "true", StringComparison.OrdinalIgnoreCase);

	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		var resources = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith("ModuleInfo.resx", StringComparison.OrdinalIgnoreCase));
		var compilation = context.CompilationProvider.Select(static (compilation, _) => new CompilationInformation { AssemblyName = compilation.AssemblyName });
		var provider = resources.Combine(context.AnalyzerConfigOptionsProvider.Combine(compilation));

		context.RegisterSourceOutput(provider, static (context, source) => {

			(var resourceFile, (var optionsProvider, var compilationInfo)) = source;
			var globalOptions = optionsProvider.GlobalOptions;

			if (!IsModuleArchendLayer(globalOptions)) return;

			try {

				List<Diagnostic> diagnostics = [];

				var resourceName = Path.GetFileNameWithoutExtension(resourceFile.Path);
				var modulePrefix = resourceName.Replace("Module", "").Replace("Info", "");
				var resourceInfo = CreateResourceInformation(optionsProvider, resourceFile, compilationInfo, modulePrefix);

				if (TryGenerateOptionsClass(resourceInfo, diagnostics, out var sourceCode)) {

					context.AddSource($"{modulePrefix}Options.g.cs", SourceText.From(sourceCode, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

				foreach (var diagnostic in diagnostics) {

					context.ReportDiagnostic(diagnostic);

				}

			} catch (OperationCanceledException) {

				throw;

			} catch (Exception exception) {

				var errorText = $"#error ModuleOptionsGenerator failed: {exception.ToString().Replace("\n", " ")}";

				context.AddSource($"Error_{Path.GetFileName(resourceFile.Path)}.g.cs", SourceText.From(errorText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

			}

		});

	}

}
