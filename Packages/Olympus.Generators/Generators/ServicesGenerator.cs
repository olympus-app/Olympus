namespace Olympus.Generators;

[Generator]
public sealed class ServicesGenerator : IIncrementalGenerator {

	private record MarkerSymbols(
		INamedTypeSymbol? Transient,
		INamedTypeSymbol? TransientGeneric,
		INamedTypeSymbol? TransientInheritor,
		INamedTypeSymbol? Scoped,
		INamedTypeSymbol? ScopedGeneric,
		INamedTypeSymbol? ScopedInheritor,
		INamedTypeSymbol? Singleton,
		INamedTypeSymbol? SingletonGeneric,
		INamedTypeSymbol? SingletonInheritor,
		INamedTypeSymbol? Settings,
		INamedTypeSymbol? Options,
		INamedTypeSymbol? OptionsGeneric,
		INamedTypeSymbol? Complex
	);

	private static bool TryGenerateSource(Compilation compilation, AnalyzerConfigOptions globalOptions, [NotNullWhen(true)] out string? sourceCode, CancellationToken cancellationToken) {

		sourceCode = string.Empty;

		if (!globalOptions.TryGetString("SolutionName", out var solutionName)) return false;
		if (!globalOptions.TryGetHostInfo(out var builderType, out var hostPrefix)) return false;

		var rootNamespace = compilation.AssemblyName ?? $"{solutionName}.{hostPrefix}.Host";
		var registrations = GetRegistrations(compilation, solutionName, cancellationToken);

		var builder = new StringBuilder(65536);

		builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable

            using Microsoft.Extensions.DependencyInjection;
            using Microsoft.Extensions.Configuration;
            using Microsoft.Extensions.Options;

            namespace {{rootNamespace}};

            /// <summary>Provides an extension method for registering discovered services.</summary>
            public static class ServicesRegistrator {

                /// <summary>Registers all discovered services implementing marker interfaces.</summary>
                public static void AddDiscoveredServices(this {{builderType}} builder) {

            {{registrations}}

                }

            }

            """);

		sourceCode = builder.ToString().TrimLines();

		return true;

	}

	private static string GetRegistrations(Compilation compilation, string solutionName, CancellationToken cancellationToken) {

		var markers = new MarkerSymbols(
			Transient: compilation.GetTypeByMetadataName("Olympus.Core.Services.ITransientService"),
			TransientGeneric: compilation.GetTypeByMetadataName("Olympus.Core.Services.ITransientService`1"),
			TransientInheritor: compilation.GetTypeByMetadataName("Olympus.Core.Services.ITransientServiceInheritor"),
			Scoped: compilation.GetTypeByMetadataName("Olympus.Core.Services.IScopedService"),
			ScopedGeneric: compilation.GetTypeByMetadataName("Olympus.Core.Services.IScopedService`1"),
			ScopedInheritor: compilation.GetTypeByMetadataName("Olympus.Core.Services.IScopedServiceInheritor"),
			Singleton: compilation.GetTypeByMetadataName("Olympus.Core.Services.ISingletonService"),
			SingletonGeneric: compilation.GetTypeByMetadataName("Olympus.Core.Services.ISingletonService`1"),
			SingletonInheritor: compilation.GetTypeByMetadataName("Olympus.Core.Services.ISingletonServiceInheritor"),
			Settings: compilation.GetTypeByMetadataName("Olympus.Core.Services.ISettingsService"),
			Options: compilation.GetTypeByMetadataName("Olympus.Core.Services.IOptionsService"),
			OptionsGeneric: compilation.GetTypeByMetadataName("Olympus.Core.Services.IOptionsService`1"),
			Complex: compilation.GetTypeByMetadataName("Olympus.Core.Services.IComplexService")
		);

		var builder = new StringBuilder();

		foreach (var assembly in compilation.GetSolutionAssemblies(solutionName)) {

			foreach (var type in assembly.GetAllTypes()) {

				cancellationToken.ThrowIfCancellationRequested();

				if (!type.IsConcreteClass() || type.DeclaredAccessibility != Accessibility.Public) continue;

				GenerateRegistration(type, markers, builder);

			}

		}

		return builder.ToString().TrimEnd();

	}

	private static void GenerateRegistration(INamedTypeSymbol type, MarkerSymbols markers, StringBuilder builder) {

		var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
		var hasComment = false;

		var transients = new List<string>();
		var scopeds = new List<string>();
		var singletons = new List<string>();

		var regTransient = false;
		var regScoped = false;
		var regSingleton = false;

		foreach (var @interface in type.AllInterfaces) {

			var originalDef = @interface.ConstructedFrom;

			if (CheckLifecycle(originalDef, markers.Transient, markers.TransientGeneric, markers.TransientInheritor, type, @interface, transients, ref regTransient)) continue;

			if (CheckLifecycle(originalDef, markers.Scoped, markers.ScopedGeneric, markers.ScopedInheritor, type, @interface, scopeds, ref regScoped)) continue;

			if (CheckLifecycle(originalDef, markers.Singleton, markers.SingletonGeneric, markers.SingletonInheritor, type, @interface, singletons, ref regSingleton)) continue;

			if (SymbolEqualityComparer.Default.Equals(originalDef, markers.Settings)) {

				EnsureComment(builder, typeName, ref hasComment);
				builder.AppendLine($"        builder.Services.AddOptions<{typeName}>().Configure<global::Microsoft.Extensions.Configuration.IConfiguration>((settings, config) => settings.Configure(config));");
				builder.AppendLine($"        builder.Services.AddSingleton<global::Olympus.Core.Settings.ISettings>(provider => provider.GetRequiredService<global::Microsoft.Extensions.Options.IOptions<{typeName}>>().Value);");
				builder.AppendLine($"        builder.Services.AddSingleton(provider => provider.GetRequiredService<global::Microsoft.Extensions.Options.IOptions<{typeName}>>().Value);");

			} else if (SymbolEqualityComparer.Default.Equals(originalDef, markers.Options)) {

				EnsureComment(builder, typeName, ref hasComment);
				builder.AppendLine($"        builder.Services.AddOptions<{typeName}>().Configure<global::Microsoft.Extensions.Configuration.IConfiguration>((settings, config) => settings.Configure(config));");
				builder.AppendLine($"        builder.Services.AddSingleton(provider => provider.GetRequiredService<global::Microsoft.Extensions.Options.IOptions<{typeName}>>().Value);");

			} else if (SymbolEqualityComparer.Default.Equals(originalDef, markers.OptionsGeneric)) {

				EnsureComment(builder, typeName, ref hasComment);
				var sType = @interface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				builder.AppendLine($"        builder.Services.AddOptions<{typeName}>().Configure<global::Microsoft.Extensions.Configuration.IConfiguration>((settings, config) => settings.Configure(config));");
				builder.AppendLine($"        builder.Services.AddSingleton<{sType}>(provider => provider.GetRequiredService<global::Microsoft.Extensions.Options.IOptions<{typeName}>>().Value);");
				builder.AppendLine($"        builder.Services.AddSingleton(provider => provider.GetRequiredService<global::Microsoft.Extensions.Options.IOptions<{typeName}>>().Value);");

			} else if (SymbolEqualityComparer.Default.Equals(originalDef, markers.Complex)) {

				EnsureComment(builder, typeName, ref hasComment);
				builder.AppendLine($"        new {typeName}().Register(builder.Services);");

			}

		}

		if (regTransient) GenerateServiceGroup(builder, typeName, "AddTransient", transients, ref hasComment);

		if (regScoped) GenerateServiceGroup(builder, typeName, "AddScoped", scopeds, ref hasComment);

		if (regSingleton) GenerateServiceGroup(builder, typeName, "AddSingleton", singletons, ref hasComment);

		if (hasComment) builder.AppendLine();

	}

	private static bool CheckLifecycle(INamedTypeSymbol originalDef, INamedTypeSymbol? marker, INamedTypeSymbol? markerGeneric, INamedTypeSymbol? markerInheritor, INamedTypeSymbol type, INamedTypeSymbol interfaceSymbol, List<string> list, ref bool flag) {

		if (SymbolEqualityComparer.Default.Equals(originalDef, marker)) {

			flag = true;

			return true;

		}

		if (SymbolEqualityComparer.Default.Equals(originalDef, markerGeneric)) {

			flag = true;

			list.Add(interfaceSymbol.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));

			return true;

		}

		if (SymbolEqualityComparer.Default.Equals(originalDef, markerInheritor)) {

			flag = true;

			CollectInheritedInterfaces(type, list);

			return true;

		}

		return false;

	}

	private static void GenerateServiceGroup(StringBuilder builder, string typeName, string method, List<string> interfaces, ref bool hasComment) {

		EnsureComment(builder, typeName, ref hasComment);

		builder.AppendLine($"        builder.Services.{method}<{typeName}>();");

		foreach (var interfaceName in interfaces.Distinct()) {

			builder.AppendLine($"        builder.Services.{method}<{interfaceName}>(provider => provider.GetRequiredService<{typeName}>());");

		}

	}

	private static void CollectInheritedInterfaces(INamedTypeSymbol type, List<string> list) {

		foreach (var implementedInterface in type.AllInterfaces) {

			var interfaceNamespace = implementedInterface.ContainingNamespace?.ToDisplayString();

			if (interfaceNamespace is not null && (interfaceNamespace.StartsWith("System") || interfaceNamespace.StartsWith("Olympus.Core.Services"))) continue;

			list.Add(implementedInterface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));

		}

	}

	private static void EnsureComment(StringBuilder builder, string typeName, ref bool hasComment) {

		if (!hasComment) {

			var cleanName = typeName.Replace("global::", "");

			builder.AppendLine($"        // {cleanName}");

			hasComment = true;

		}

	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		var compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

		context.RegisterSourceOutput(compilationAndOptions, static (context, source) => {

			(var compilation, var optionsProvider) = source;
			var globalOptions = optionsProvider.GlobalOptions;

			try {

				List<Diagnostic> diagnostics = [];

				if (TryGenerateSource(compilation, globalOptions, out var sourceText, context.CancellationToken)) {

					context.AddSource("ServicesRegistrator.g.cs", SourceText.From(sourceText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

				foreach (var diagnostic in diagnostics) {

					context.ReportDiagnostic(diagnostic);

				}

			} catch (OperationCanceledException) {

				throw;

			} catch (Exception exception) {

				var errorText = $"#error ServicesGenerator failed: {exception.ToString().Replace("\n", " ")}";
				context.AddSource("Error_ServicesGenerator.g.cs", SourceText.From(errorText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

			}

		});

	}

}
