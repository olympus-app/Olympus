namespace Olympus.Generators;

[Generator]
public sealed class MapperGenerator : IIncrementalGenerator {

	private const int MaxRecursionDepth = 10;

	private const string IEntityInterface = "Olympus.Core.Backend.Entities.IEntity";
	private const string IEntityRequestInterface = "Olympus.Core.Archend.Entities.IEntityRequest";
	private const string IEntityResponseInterface = "Olympus.Core.Archend.Entities.IEntityResponse";
	private const string IEntityRequestMapperInterface = "Olympus.Core.Backend.Entities.IEntityRequestMapper`2";
	private const string IEntityResponseMapperInterface = "Olympus.Core.Backend.Entities.IEntityResponseMapper`2";

	private record EntityInfo(string Name, string FullName, string Namespace, INamedTypeSymbol Symbol);
	private record DtoInfo(string Name, string FullName, string Namespace, INamedTypeSymbol Symbol, bool IsRequest, bool IsResponse);
	private record MapperGroup(string Name, EntityInfo Entity, List<DtoInfo> Dtos);
	private record PropertyMap(string DtoProp, string EntityProp, bool CanWriteToDto, bool CanWriteToEntity, bool IsDtoInit, bool IsEntityInit, bool IsNested, List<PropertyMap>? NestedMaps, string? NestedDtoType, string? NestedEntityType);

	private static List<EntityInfo> GetEntities(Compilation compilation) {

		var entities = new List<EntityInfo>();
		var entitySymbol = compilation.GetTypeByMetadataName(IEntityInterface);

		if (entitySymbol is null) return entities;

		var currentAssembly = compilation.Assembly;

		foreach (var type in currentAssembly.GetAllTypes()) {

			if (type.IsConcreteClass() && type.Implements(entitySymbol)) {

				entities.Add(new EntityInfo(type.Name, type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), type.ContainingNamespace.ToDisplayString(), type));

			}

		}

		return entities;

	}

	private static List<DtoInfo> GetDtos(Compilation compilation, string solutionName) {

		var dtos = new List<DtoInfo>();
		var requestSymbol = compilation.GetTypeByMetadataName(IEntityRequestInterface);
		var responseSymbol = compilation.GetTypeByMetadataName(IEntityResponseInterface);

		foreach (var assembly in compilation.GetSolutionAssemblies(solutionName)) {

			foreach (var type in assembly.GetAllTypes()) {

				if (!type.IsConcreteClass()) continue;

				var isRequest = requestSymbol is not null && type.Implements(requestSymbol);
				var isResponse = responseSymbol is not null && type.Implements(responseSymbol);

				if (isRequest || isResponse) {

					dtos.Add(new DtoInfo(type.Name, type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), type.ContainingNamespace.ToDisplayString(), type, isRequest, isResponse));

				}

			}

		}

		return dtos;

	}

	private static List<MapperGroup> GroupDtosByMapper(List<DtoInfo> dtos, List<EntityInfo> entities) {

		var groups = new Dictionary<string, MapperGroup>();

		foreach (var dto in dtos) {

			if (TryFindEntityMatch(dto, entities, out var entity)) {

				var mapperName = dto.Name.Replace("Request", "").Replace("Response", "") + "Mapper";

				if (!groups.TryGetValue(mapperName, out var group)) {

					group = new MapperGroup(mapperName, entity, []);
					groups[mapperName] = group;

				}

				if (group.Entity.FullName == entity.FullName) group.Dtos.Add(dto);

			}

		}

		return groups.Values.ToList();

	}

	private static bool TryFindEntityMatch(DtoInfo dto, List<EntityInfo> entities, [NotNullWhen(true)] out EntityInfo? match) {

		var candidates = entities.Where(e => dto.Name.StartsWith(e.Name)).OrderByDescending(e => e.Name.Length).ToList();

		if (candidates.Count == 0) { match = null; return false; }

		match = candidates.FirstOrDefault(c => AreNamespacesSimilar(c.Namespace, dto.Namespace)) ?? candidates.First();

		return true;

	}

	private static bool AreNamespacesSimilar(string ns1, string ns2) {

		var parts1 = ns1.Split('.');

		var parts2 = ns2.Split('.');

		return parts1.Intersect(parts2).Count() >= 3;

	}

	private static string GenerateMapperClass(MapperGroup group) {

		var mapperNamespace = group.Entity.Namespace;
		var entityFullName = group.Entity.FullName;
		var interfaces = new List<string>();

		foreach (var dto in group.Dtos) {

			if (dto.IsRequest) interfaces.Add($"global::{IEntityRequestMapperInterface.Split('`')[0]}<{entityFullName}, {dto.FullName}>");

			if (dto.IsResponse) interfaces.Add($"global::{IEntityResponseMapperInterface.Split('`')[0]}<{entityFullName}, {dto.FullName}>");

		}

		var dtoNames = string.Join(", ", group.Dtos.Select(d => d.Name));
		var inheritedInterfaces = string.Join(", ", interfaces);

		var builder = new StringBuilder(4096);
		builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable
            #pragma warning disable CS8601

            namespace {{mapperNamespace}};

            /// <summary>Mapper class for {{group.Entity.Name}} entity and {{dtoNames}}.</summary>
            public sealed partial class {{group.Name}} : {{inheritedInterfaces}} {
            """);

		foreach (var dto in group.Dtos) {

			var propertyMaps = GetPropertyMaps(dto.Symbol, group.Entity.Symbol, recursionDepth: 0);

			if (dto.IsRequest) GenerateRequestMethods(builder, dto, group.Entity, propertyMaps);
			else GenerateResponseMethods(builder, dto, group.Entity, propertyMaps);

		}

		builder.AppendLine();
		builder.AppendLine("}");

		return builder.ToString();

	}

	private static void GenerateRequestMethods(StringBuilder builder, DtoInfo dto, EntityInfo entity, List<PropertyMap> maps) {

		var interfaceName = $"global::{IEntityRequestMapperInterface.Split('`')[0]}<{entity.FullName}, {dto.FullName}>";

		// MapToEntity
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Creates a new instance of <see cref=\"{entity.FullName}\"/> from the provided <see cref=\"{dto.FullName}\"/>.</summary>");
		builder.AppendLine($"    /// <param name=\"request\">The source request DTO.</param>");
		builder.AppendLine($"    /// <returns>The mapped entity instance.</returns>");
		builder.AppendLine($"    {entity.FullName} {interfaceName}.MapToEntity({dto.FullName} request) {{");
		builder.AppendLine();
		builder.AppendLine($"        var entity = new {entity.FullName} {{");

		GenerateAssignments(builder, maps, "request", toDto: false, "            ");

		builder.AppendLine("        };");
		builder.AppendLine();
		builder.AppendLine("        OnAfterMapToEntity(request, entity);");
		builder.AppendLine();
		builder.AppendLine("        return entity;");
		builder.AppendLine();
		builder.AppendLine("    }");
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Hook executed after mapping to entity.</summary>");
		builder.AppendLine($"    partial void OnAfterMapToEntity({dto.FullName} request, {entity.FullName} entity);");

		// MapFromEntity
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Creates a new instance of <see cref=\"{dto.FullName}\"/> from the provided <see cref=\"{entity.FullName}\"/>.</summary>");
		builder.AppendLine($"    /// <param name=\"entity\">The source entity.</param>");
		builder.AppendLine($"    /// <returns>The mapped request DTO.</returns>");
		builder.AppendLine($"    {dto.FullName} {interfaceName}.MapFromEntity({entity.FullName} entity) {{");
		builder.AppendLine();
		builder.AppendLine($"        var request = new {dto.FullName} {{");

		GenerateAssignments(builder, maps, "entity", toDto: true, "            ");

		builder.AppendLine("        };");
		builder.AppendLine();
		builder.AppendLine($"        OnAfterMapFromEntity(entity, request);");
		builder.AppendLine();
		builder.AppendLine("        return request;");
		builder.AppendLine();
		builder.AppendLine("    }");
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Hook executed after mapping from entity.</summary>");
		builder.AppendLine($"    partial void OnAfterMapFromEntity({entity.FullName} entity, {dto.FullName} request);");

		// UpdateEntity
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Updates an existing <see cref=\"{entity.FullName}\"/> using values from <see cref=\"{dto.FullName}\"/>.</summary>");
		builder.AppendLine($"    /// <param name=\"entity\">The entity to update.</param>");
		builder.AppendLine($"    /// <param name=\"request\">The source request DTO.</param>");
		builder.AppendLine($"    void {interfaceName}.UpdateEntity({entity.FullName} entity, {dto.FullName} request) {{");
		builder.AppendLine();
		builder.AppendLine("        OnBeforeUpdateEntity(entity, request);");
		builder.AppendLine();

		foreach (var map in maps) {

			if (map.CanWriteToEntity && !map.IsEntityInit && !map.IsNested) {

				builder.AppendLine($"        entity.{map.EntityProp} = request.{map.DtoProp};");

			}

		}

		builder.AppendLine();
		builder.AppendLine("        OnAfterUpdateEntity(entity, request);");
		builder.AppendLine();
		builder.AppendLine("    }");
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Hook executed before updating the entity.</summary>");
		builder.AppendLine($"    partial void OnBeforeUpdateEntity({entity.FullName} entity, {dto.FullName} request);");
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Hook executed after updating the entity.</summary>");
		builder.AppendLine($"    partial void OnAfterUpdateEntity({entity.FullName} entity, {dto.FullName} request);");

		// ProjectFromEntity (Expression)
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Generates a projection expression to map <see cref=\"{entity.FullName}\"/> to <see cref=\"{dto.FullName}\"/>.</summary>");
		builder.AppendLine($"    /// <returns>The projection expression.</returns>");
		builder.AppendLine($"    global::System.Linq.Expressions.Expression<global::System.Func<{entity.FullName}, {dto.FullName}>> {interfaceName}.ProjectFromEntity() {{");
		builder.AppendLine();
		builder.AppendLine($"        return entity => new {dto.FullName} {{");

		GenerateAssignments(builder, maps, "entity", toDto: true, "            ");

		builder.AppendLine("        };");
		builder.AppendLine();
		builder.AppendLine("    }");

		// ProjectFromEntity (IQueryable)
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Projects the query to <see cref=\"{dto.FullName}\"/> using the projection expression.</summary>");
		builder.AppendLine($"    global::System.Linq.IQueryable<{dto.FullName}> {interfaceName}.ProjectFromEntity(global::System.Linq.IQueryable<{entity.FullName}> query) {{");
		builder.AppendLine();
		builder.AppendLine($"        return query.Select((({interfaceName})this).ProjectFromEntity());");
		builder.AppendLine();
		builder.AppendLine("    }");

	}

	private static void GenerateResponseMethods(StringBuilder builder, DtoInfo dto, EntityInfo entity, List<PropertyMap> maps) {

		var interfaceName = $"global::{IEntityResponseMapperInterface.Split('`')[0]}<{entity.FullName}, {dto.FullName}>";

		// MapToEntity
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Creates a new instance of <see cref=\"{entity.FullName}\"/> from the provided <see cref=\"{dto.FullName}\"/>.</summary>");
		builder.AppendLine($"    /// <param name=\"response\">The source response DTO.</param>");
		builder.AppendLine($"    /// <returns>The mapped entity instance.</returns>");
		builder.AppendLine($"    {entity.FullName} {interfaceName}.MapToEntity({dto.FullName} response) {{");
		builder.AppendLine();
		builder.AppendLine($"        var entity = new {entity.FullName} {{");

		GenerateAssignments(builder, maps, "response", toDto: false, "            ");

		builder.AppendLine("        };");
		builder.AppendLine();
		builder.AppendLine("        OnAfterMapToEntity(response, entity);");
		builder.AppendLine();
		builder.AppendLine("        return entity;");
		builder.AppendLine();
		builder.AppendLine("    }");
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Hook executed after mapping to entity.</summary>");
		builder.AppendLine($"    partial void OnAfterMapToEntity({dto.FullName} response, {entity.FullName} entity);");

		// MapFromEntity
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Creates a new instance of <see cref=\"{dto.FullName}\"/> from the provided <see cref=\"{entity.FullName}\"/>.</summary>");
		builder.AppendLine($"    /// <param name=\"entity\">The source entity.</param>");
		builder.AppendLine($"    /// <returns>The mapped response DTO.</returns>");
		builder.AppendLine($"    {dto.FullName} {interfaceName}.MapFromEntity({entity.FullName} entity) {{");
		builder.AppendLine();
		builder.AppendLine($"        var response = new {dto.FullName} {{");

		GenerateAssignments(builder, maps, "entity", toDto: true, "            ");

		builder.AppendLine("        };");
		builder.AppendLine();
		builder.AppendLine("        OnAfterMapFromEntity(entity, response);");
		builder.AppendLine();
		builder.AppendLine("        return response;");
		builder.AppendLine();
		builder.AppendLine("    }");
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Hook executed after mapping from entity.</summary>");
		builder.AppendLine($"    partial void OnAfterMapFromEntity({entity.FullName} entity, {dto.FullName} response);");

		// ProjectFromEntity (Expression)
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Generates a projection expression to map <see cref=\"{entity.FullName}\"/> to <see cref=\"{dto.FullName}\"/>.</summary>");
		builder.AppendLine($"    /// <returns>The projection expression.</returns>");
		builder.AppendLine($"    global::System.Linq.Expressions.Expression<global::System.Func<{entity.FullName}, {dto.FullName}>> {interfaceName}.ProjectFromEntity() {{");
		builder.AppendLine();
		builder.AppendLine($"        return entity => new {dto.FullName} {{");

		GenerateAssignments(builder, maps, "entity", toDto: true, "            ");

		builder.AppendLine("        };");
		builder.AppendLine();
		builder.AppendLine("    }");

		// ProjectFromEntity (IQueryable - Syntax Sugar)
		builder.AppendLine();
		builder.AppendLine($"    /// <summary>Projects the query to <see cref=\"{dto.FullName}\"/> using the projection expression.</summary>");
		builder.AppendLine($"    global::System.Linq.IQueryable<{dto.FullName}> {interfaceName}.ProjectFromEntity(global::System.Linq.IQueryable<{entity.FullName}> query) {{");
		builder.AppendLine();
		builder.AppendLine($"        return query.Select((({interfaceName})this).ProjectFromEntity());");
		builder.AppendLine();
		builder.AppendLine("    }");

	}

	private static void GenerateAssignments(StringBuilder builder, List<PropertyMap> maps, string sourceVar, bool toDto, string indent) {

		foreach (var map in maps) {

			var canWrite = toDto ? map.CanWriteToDto : map.CanWriteToEntity;
			if (!canWrite) continue;

			var targetProp = toDto ? map.DtoProp : map.EntityProp;
			var sourceProp = toDto ? map.EntityProp : map.DtoProp;

			if (!map.IsNested) {

				builder.AppendLine($"{indent}{targetProp} = {sourceVar}.{sourceProp},");

			} else {

				if (map.NestedMaps is not null) {

					var targetType = toDto ? map.NestedDtoType : map.NestedEntityType;

					builder.AppendLine($"{indent}{targetProp} = {sourceVar}.{sourceProp} != null ? new {targetType} {{");

					GenerateAssignments(builder, map.NestedMaps, $"{sourceVar}.{sourceProp}", toDto, indent + "    ");

					builder.AppendLine($"{indent}}} : default,");

				}

			}

		}

	}

	private static List<PropertyMap> GetPropertyMaps(INamedTypeSymbol dto, INamedTypeSymbol entity, int recursionDepth) {

		var maps = new List<PropertyMap>();
		var dtoProps = GetAccessibleProperties(dto, false);
		var entityProps = GetAccessibleProperties(entity, true);

		foreach (var dProp in dtoProps) {

			var eProp = entityProps.FirstOrDefault(e => e.Name == dProp.Name);

			if (eProp is null) continue;

			var isNested = false;

			List<PropertyMap>? nestedMaps = null;

			if (AreTypesCompatible(dProp.Type, eProp.Type)) {

				isNested = false;

			} else if (recursionDepth < MaxRecursionDepth && IsClass(dProp.Type) && IsClass(eProp.Type)) {

				var dType = (INamedTypeSymbol)UnwrapNullable(dProp.Type);
				var eType = (INamedTypeSymbol)UnwrapNullable(eProp.Type);
				var childMaps = GetPropertyMaps(dType, eType, recursionDepth + 1);

				if (childMaps.Count > 0) {

					isNested = true;
					nestedMaps = childMaps;

				}

			}

			if (AreTypesCompatible(dProp.Type, eProp.Type) || isNested) {

				maps.Add(new PropertyMap(
					DtoProp: dProp.Name,
					EntityProp: eProp.Name,
					CanWriteToDto: IsWritable(dProp, false),
					CanWriteToEntity: IsWritable(eProp, true),
					IsDtoInit: IsInitOnly(dProp),
					IsEntityInit: IsInitOnly(eProp),
					IsNested: isNested,
					NestedMaps: nestedMaps,
					NestedDtoType: dProp.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
					NestedEntityType: eProp.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
				));

			}

		}

		return maps;

	}

	private static IEnumerable<IPropertySymbol> GetAccessibleProperties(INamedTypeSymbol symbol, bool allowInternal) {

		var props = new List<IPropertySymbol>();
		var current = symbol;

		while (current is not null) {

			props.AddRange(current.GetMembers().OfType<IPropertySymbol>().Where(prop => {

				if (prop.IsStatic) return false;

				if (prop.DeclaredAccessibility == Accessibility.Public) return true;

				if (allowInternal && (prop.DeclaredAccessibility == Accessibility.Internal || prop.DeclaredAccessibility == Accessibility.ProtectedOrInternal)) return true;

				return false;

			}));

			current = current.BaseType;

		}

		return props;

	}

	private static bool IsInitOnly(IPropertySymbol property) {

		return property.SetMethod?.IsInitOnly == true;

	}

	private static bool IsWritable(IPropertySymbol property, bool allowInternal) {

		if (property.SetMethod is null) return false;

		var accessibility = property.SetMethod.DeclaredAccessibility;

		if (accessibility == Accessibility.Public) return true;

		if (allowInternal && (accessibility == Accessibility.Internal || accessibility == Accessibility.ProtectedOrInternal)) return true;

		return false;

	}

	private static bool IsClass(ITypeSymbol type) {

		return type.IsReferenceType && type.TypeKind == TypeKind.Class && type.SpecialType != SpecialType.System_String;

	}

	private static ITypeSymbol UnwrapNullable(ITypeSymbol type) {

		if (type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T) return ((INamedTypeSymbol)type).TypeArguments[0];

		return type;

	}

	private static bool AreTypesCompatible(ITypeSymbol t1, ITypeSymbol t2) {

		return SymbolEqualityComparer.Default.Equals(t1, t2) || SymbolEqualityComparer.Default.Equals(UnwrapNullable(t1), UnwrapNullable(t2));

	}

	private static bool IsModuleBackendLayer(AnalyzerConfigOptions globalOptions) {

		globalOptions.TryGetValue("build_property.IsModulePackage", out var isModule);
		globalOptions.TryGetValue("build_property.IsBackendLayer", out var isBackend);

		return string.Equals(isModule, "true", StringComparison.OrdinalIgnoreCase) && string.Equals(isBackend, "true", StringComparison.OrdinalIgnoreCase);

	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		var compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

		context.RegisterSourceOutput(compilationAndOptions, static (context, source) => {

			(var compilation, var optionsProvider) = source;
			var globalOptions = optionsProvider.GlobalOptions;

			if (!IsModuleBackendLayer(globalOptions)) return;

			if (!globalOptions.TryGetString("SolutionName", out var solutionName)) return;

			try {

				var entities = GetEntities(compilation);
				var dtos = GetDtos(compilation, solutionName);
				var groups = GroupDtosByMapper(dtos, entities);

				foreach (var group in groups) {

					var sourceCode = GenerateMapperClass(group).TrimLines();

					context.AddSource($"{group.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

			} catch (Exception exception) {

				var errorText = $"#error MapperGenerator failed: {exception.ToString().Replace("\n", " ")}";

				context.AddSource("Error_MapperGenerator.g.cs", SourceText.From(errorText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

			}

		});

	}

}
