namespace Olympus.Generators;

[Generator]
public sealed class LocalizationGenerator : IIncrementalGenerator {

	private readonly struct ResourceString {

		private static readonly Regex NamedParameterMatcher = new(@"\{([a-z]\w*)\}", RegexOptions.IgnoreCase | RegexOptions.Compiled);
		private static readonly Regex NumberParameterMatcher = new(@"\{(\d+)\}", RegexOptions.Compiled);
		private readonly IReadOnlyList<string> Arguments;

		public ResourceString(string identifier, string value) {

			Identifier = identifier;
			Value = value;

			var match = NamedParameterMatcher.Matches(value);

			UsingNamedArgs = match.Count > 0;

			if (!UsingNamedArgs) match = NumberParameterMatcher.Matches(value);

			var arguments = match.Cast<Match>().Select(m => m.Groups[1].Value).Distinct();

			if (!UsingNamedArgs) arguments = arguments.OrderBy(Convert.ToInt32);

			Arguments = arguments.ToList();

		}

		public string Identifier { get; }

		public string Value { get; }

		public bool UsingNamedArgs { get; }

		public bool HasArguments => Arguments.Count > 0;

		public string GetArgumentNames() => string.Join(", ", Arguments.Select(arg => "\"" + arg + "\""));

		public IEnumerable<string> GetArguments() => UsingNamedArgs ? Arguments : Arguments.Select(arg => 'x' + arg);

		public string GetJoinedArguments() => string.Join(", ", GetArguments());

		public string GetMethodParameters() => string.Join(", ", GetArguments().Select(arg => "object? " + arg));

	}

	private static bool TryGenerateSource(ResourceCollection resourceCollection, in List<Diagnostic> diagnostics, [NotNullWhen(true)] out string? sourceCode, CancellationToken cancellationToken) {

		var info = resourceCollection.BaseInformation;

		if (!TryGenerateMembers(resourceCollection, out var valueMembers, out var nameMembers, out var keyMembers, diagnostics, cancellationToken)) {

			sourceCode = string.Empty;

			return false;

		}

		var rootNamespace = info.ResourceSettings.Namespace;
		var className = info.ClassName;
		var resourceName = info.ResourceName;
		var visibility = info.ResourceSettings.IsPublic ? "public" : "internal";
		var cultureCode = BuildHelper.GetCultureCode(null);
		var singletonCode = BuildHelper.GetSingletonCode(className);
		var resourceManagerCode = BuildHelper.GetResourceManagerCode(resourceName, className, true);
		var getStringCode = BuildHelper.GetGetStringCode(true);

		var builder = new StringBuilder(8192);

		builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable

            namespace {{rootNamespace}};

            /// <summary>Localization class for '{{info.ResourceFile.Path}}'.</summary>
            {{visibility}} sealed partial class {{className}} {

            {{singletonCode}}

            {{cultureCode}}

            {{resourceManagerCode}}

            {{getStringCode}}

                /// <summary>Gets a resource of the <see cref="ResourceManager"/> with the configured <see cref="Culture"/> as a string using <see cref="Keys"/>.</summary>
                /// <param name="key">The resource key to look up.</param>
                /// <returns>The localized string if found; otherwise, the resource key.</returns>
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public string GetString(Keys key) => GetString(key.ToString());

                /// <summary>Gets a value of the <see cref="Values"/> instance with the configured <see cref="Culture"/> as a string.</summary>
                /// <param name="key">The value key to look up.</param>
                /// <returns>The localized value if found; otherwise, the value key.</returns>
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public static string GetValue(string key) => Values.GetString(key);

                /// <summary>Gets a value of the <see cref="Values"/> instance with the configured <see cref="Culture"/> as a string using <see cref="Keys"/>.</summary>
                /// <param name="key">The value key to look up.</param>
                /// <returns>The localized value if found; otherwise, the value key.</returns>
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public static string GetValue(Keys key) => Values.GetString(key);

                /// <summary>Gets a resource of the <see cref="ResourceManager"/> with the configured <see cref="Culture"/> as a string.</summary>
                /// <param name="key">The resource key to look up.</param>
                /// <returns>The localized string if found; otherwise, the resource key.</returns>
                public string this[string key] => GetString(key);

                /// <summary>Gets a resource of the <see cref="ResourceManager"/> with the configured <see cref="Culture"/> as a string using <see cref="Keys"/>.</summary>
                /// <param name="key">The resource key to look up.</param>
                /// <returns>The localized string if found; otherwise, the resource key.</returns>
                public string this[Keys key] => GetString(key.ToString());

            {{valueMembers}}

                /// <summary>All names in <see cref="{{className}}"/> as constants.</summary>
                public static class Names {

            {{nameMembers}}

                }

                /// <summary>All keys in <see cref="{{className}}"/> as enums.</summary>
                public enum Keys {

            {{keyMembers}}

                }

            }

            """);

		sourceCode = builder.ToString().TrimLines();

		return true;

	}

	private static bool TryGenerateMembers(ResourceCollection resourceCollection, [NotNullWhen(true)] out string? valueMembers, [NotNullWhen(true)] out string? nameMembers, [NotNullWhen(true)] out string? keyMembers, in List<Diagnostic> diagnostics, CancellationToken cancellationToken) {

		var info = resourceCollection.BaseInformation;
		var valueMembersBuilder = new StringBuilder(4096);
		var nameMembersBuilder = new StringBuilder(1024);
		var keyMembersBuilder = new StringBuilder(1024);

		if (!info.ResourceFile.TryGetResourceDataAndValues(diagnostics, out var values, cancellationToken)) {

			valueMembers = nameMembers = keyMembers = null;

			return false;

		}

		if (values.Count == 0) {

			valueMembers = nameMembers = keyMembers = null;

			diagnostics.Add(Diagnostic.Create(BuildHelper.EmptyResourceFile, Location.Create(info.ResourceFile.Path, default, default)));

			return false;

		}

		var otherCulturesEntries = new Dictionary<CultureInfo, Dictionary<string, XElement>>();

		foreach (var pair in resourceCollection.OtherLanguages) {

			if (pair.Value.TryGetResourceDataAndValues(diagnostics, out var langSpecificValues, cancellationToken)) {

				otherCulturesEntries[pair.Key] = langSpecificValues;

			}

		}

		foreach (var x in values) {

			(var name, var attribute) = (x.Key, x.Value);
			var value = attribute.Value.Trim();
			var propertyIdentifier = BuildHelper.GetIdentifierFromResourceName(name);

			var docComment = GenerateDocComment(info.ResourceSettings.DefaultLang, value, otherCulturesEntries, name, diagnostics, resourceCollection);

			valueMembersBuilder.AppendLine($$"""
                /// <summary>Gets the value of <see cref="Keys.{{propertyIdentifier}}"/>.<list type="table">
            {{docComment}}
                /// <item><description>â €</description></item></list></summary>
                public string @{{propertyIdentifier}} => GetString(Keys.{{propertyIdentifier}});

            """);

			if (info.ResourceSettings.EmitFormatMethods) {

				var resourceString = new ResourceString(propertyIdentifier, value);

				if (resourceString.HasArguments) GenerateFormatMethod(valueMembersBuilder, resourceString);

			}

			nameMembersBuilder.AppendLine($$"""
                    /// <summary>Gets the name of <see cref="Keys.{{propertyIdentifier}}"/>.<list type="table">
            {{docComment.Replace("    ", "        ")}}</list></summary>
                    public const string @{{propertyIdentifier}} = @"{{name}}";

            """);

			keyMembersBuilder.AppendLine($$"""
                    /// <summary>Gets the key of <see cref="Keys.{{propertyIdentifier}}"/>.<list type="table">
            {{docComment.Replace("    ", "        ")}}</list></summary>
                    @{{propertyIdentifier}},

            """);

		}

		valueMembers = valueMembersBuilder.ToString().TrimEnd();
		nameMembers = nameMembersBuilder.ToString().TrimEnd();
		keyMembers = keyMembersBuilder.ToString().TrimEnd();

		return true;

	}

	private static string GenerateDocComment(string defaultLang, string defaultValue, Dictionary<CultureInfo, Dictionary<string, XElement>> otherCultures, string resourceName, List<Diagnostic> diagnostics, ResourceCollection resourceCollection) {

		var builder = new StringBuilder();

		builder.AppendLine($"    /// <item><b>{defaultLang}</b>: {BuildHelper.GetTrimmedDocComment(defaultValue)}</item>");

		foreach (var entry in otherCultures.OrderBy(item => item.Key.ToString())) {

			string otherValue;

			if (entry.Value.TryGetValue(resourceName, out var otherAttribute)) {

				otherValue = otherAttribute.Value.Trim();

			} else {

				diagnostics.Add(Diagnostic.Create(BuildHelper.MissingResourceTranslation, Location.Create(resourceCollection.OtherLanguages[entry.Key].Path, default, default), resourceName, entry.Key.DisplayName, entry.Key));

				otherValue = "[missing]";

			}

			builder.AppendLine($"    /// <item><b>{entry.Key}</b>: {BuildHelper.GetTrimmedDocComment(otherValue)}</item>");

		}

		return builder.ToString().TrimEnd();

	}

	private static void GenerateFormatMethod(StringBuilder builder, ResourceString resourceString) {

		var propertyIdentifier = resourceString.Identifier;
		var methodParameters = resourceString.GetMethodParameters();
		var arguments = resourceString.GetJoinedArguments();

		var argumentNames = resourceString.UsingNamedArgs ? $"GetString(@{propertyIdentifier}, new[] {{ {resourceString.GetArgumentNames()} }})" : $"@{propertyIdentifier}";
		var paramDocs = string.Join("\n", resourceString.GetArguments().Select((x, i) => $"    /// <param name=\"{x}\">The parameter to be used at position {{{i}}}.</param>"));

		builder.AppendLine($$"""
                /// <summary>Formats the content of <see cref="Keys.{{propertyIdentifier}}"/>.</summary>
                /// {{BuildHelper.GetTrimmedDocComment(resourceString.Value)}}
            {{paramDocs}}
                /// <returns>The formatted <see cref="Keys.{{propertyIdentifier}}"/> content.</returns>
                public string @Format{{propertyIdentifier}}({{methodParameters}}) => string.Format(Culture, {{argumentNames}}, {{arguments}});

            """);

	}

	private static ResourceInformation[] CreateResourceInformation(AnalyzerConfigOptionsProvider optionsProvider, AdditionalText resourceFile, CompilationInformation compilationInfo) {

		var globalOptions = optionsProvider.GlobalOptions;
		var resourceOptions = optionsProvider.GetOptions(resourceFile);

		if (!(resourceOptions.GetValue("build_metadata.EmbeddedResource.ResourceType") == "Localization")) return [];

		var rootNamespace = globalOptions.GetValue("build_property.RootNamespace") ?? compilationInfo.AssemblyName;
		var customNamespace = resourceOptions.GetValue("build_metadata.EmbeddedResource.Namespace");
		var isPublic = resourceOptions.GetBoolValue("build_metadata.EmbeddedResource.IsPublic") ?? true;
		var className = resourceOptions.GetValue("build_metadata.EmbeddedResource.ClassName");
		var defaultLang = resourceOptions.GetValue("build_metadata.EmbeddedResource.DefaultLang");
		var emitFormatMethods = resourceOptions.GetBoolValue("build_metadata.EmbeddedResource.EmitFormatMethods") ?? true;
		var resourceFileName = Path.GetFileNameWithoutExtension(resourceFile.Path);
		var resourceAccessName = className is null || string.IsNullOrEmpty(className) ? string.Join(".", rootNamespace, resourceFileName) : className;

		BuildHelper.SplitName(resourceAccessName, out var resourceNamespace, out var resourceClassName);

		return [
			new ResourceInformation() {
				CompilationInformation = compilationInfo,
				ResourceFile = resourceFile,
				ResourceSettings = new ResourceSettings {
					IsPublic = isPublic,
					RootNamespace = rootNamespace,
					Namespace = !string.IsNullOrEmpty(customNamespace) ? customNamespace : resourceNamespace,
					ClassName = !string.IsNullOrEmpty(className) ? className : resourceClassName,
					DefaultLang = !string.IsNullOrEmpty(defaultLang) ? defaultLang : "Default",
					EmitFormatMethods = emitFormatMethods,
				},
				ResourceFileName = resourceFileName,
				ResourceName = string.Join(".", rootNamespace, resourceFileName),
				Namespace = resourceNamespace,
				ClassName = resourceClassName,
			},
		];

	}

	private static ImmutableDictionary<ResourceInformation, string> CreateNamePrefixMapping(ImmutableArray<ResourceInformation> resource) {

		var names = new HashSet<string>();
		var remappedNames = ImmutableDictionary<ResourceInformation, string>.Empty;

		foreach (var resourceInformation in resource.OrderBy(info => info.ResourceName, StringComparer.Ordinal)) {

			for (var i = -1; ; i++) {

				if (i == -1) {

					if (names.Add(resourceInformation.ResourceFileName)) break;

				} else {

					var candidateName = i.ToString(CultureInfo.InvariantCulture);

					if (!names.Add(candidateName)) continue;

					remappedNames = remappedNames.Add(resourceInformation, candidateName);

					break;

				}

			}

		}

		return remappedNames;

	}

	private static ResourceCollection CreateResourceCollection(ImmutableDictionary<ResourceInformation, string> mappings, ResourceInformation resource, ImmutableArray<ResourceInformation> allFiles) {

		var fileHintName = mappings.TryGetValue(resource, out var fileMapping) ? $"{resource.ResourceFileName}{fileMapping}.Designer.g.cs" : $"{resource.ResourceFileName}.Designer.g.cs";

		return new ResourceCollection {
			BaseInformation = resource,
			OtherLanguages = allFiles
				.Where(x => x != resource)
				.Select(x => {
					var isChildFile = BuildHelper.IsChildFile(
						x.ResourceName,
						[resource.ResourceName],
						out var cultureInfo
					);
					return !isChildFile ? ((CultureInfo?, AdditionalText)?)null : (cultureInfo, x.ResourceFile);
				})
				.Where(x => x is not null)
				.ToImmutableDictionary(x => x!.Value.Item1!, x => x!.Value.Item2),
			FileHintName = fileHintName,
		};

	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		var resources = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith(".resx", StringComparison.OrdinalIgnoreCase) && file.Path.IndexOf("ModuleInfo", StringComparison.OrdinalIgnoreCase) < 0 && file.Path.IndexOf("Permissions", StringComparison.OrdinalIgnoreCase) < 0 && file.Path.IndexOf("Routes", StringComparison.OrdinalIgnoreCase) < 0);
		var compilation = context.CompilationProvider.Select(static (compilation, _) => new CompilationInformation { AssemblyName = compilation.AssemblyName });

		var resourcesToGenerate = resources
			.Combine(context.AnalyzerConfigOptionsProvider
			.Combine(compilation))
			.SelectMany(
				static (values, _) => {
					(var resourceFile, (var optionsProvider, var compilationInfo)) = values;
					return CreateResourceInformation(optionsProvider, resourceFile, compilationInfo);
				}
			);

		var allFiles = resourcesToGenerate.Collect();

		var renameMapping = allFiles
			.Select(static (values, _) => CreateNamePrefixMapping(values))
			.WithComparer(ImmutableDictionaryEqualityComparer<ResourceInformation, string>.Instance);

		var resourcesToGenerateWithNames = resourcesToGenerate
			.Combine(renameMapping)
			.Combine(allFiles)
			.Where(static values => {
				((var resource, _), var allFiles) = values;
				return !BuildHelper.IsChildFile(resource.ResourceName, allFiles.Select(r => r.ResourceName), out _);
			})
			.Select(
				static (values, _) => {
					((var resource, var mappings), var allFiles) = values;
					return CreateResourceCollection(mappings, resource, allFiles);
				}
			);

		context.RegisterSourceOutput(

			resourcesToGenerateWithNames,

			static (context, resourceInformation) => {

				try {

					List<Diagnostic> diagnostics = [];

					if (TryGenerateSource(resourceInformation, diagnostics, out var sourceText, context.CancellationToken)) {

						context.AddSource(
							resourceInformation.FileHintName,
							SourceText.From(sourceText, Encoding.UTF8, SourceHashAlgorithm.Sha256)
						);

					}

					foreach (var diagnostic in diagnostics) {

						context.ReportDiagnostic(diagnostic);

					}

				} catch (OperationCanceledException) {

					throw;

				} catch (Exception exception) {

					var errorText = $"#error LocalizationGenerator failed: {exception.ToString().Replace("\n", " ")}";
					context.AddSource("Error_LocalizationGenerator.g.cs", SourceText.From(errorText, Encoding.UTF8, SourceHashAlgorithm.Sha256));

				}

			}

		);

	}

}
